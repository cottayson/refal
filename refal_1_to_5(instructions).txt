1. Найти в‍ последовательности два наибольших значения. 
Пример: для последовательности 1 1 2 2 3 1 ответом будет 2 и 3.

// точка входа программы
$ENTRY Go { 
= <Print <TwoMax 1 1 2 2 3 1> >;

// функция Print выводит на печать любые скобочные последовательности, числа, ...
// чтобы вывести русское слово нужно заключить его в кавычки: "Привет"  или так 'Привет'
}

/* TwoMax - вычисляет список из двух атомов 
1. second max   // второстепенный
2. maximum      // главный максимум

1 1 2 2 3 1 -> 2 3
2 1 1 -> 1 2
*/

TwoMax {
  '' = Empty;
  e.seq = <SecondMax e.seq> <Max e.seq>;
  e.1 = e.1 STOP;
}

/* 
SecondMax вычисляет второй максимум(он точно меньше первого)
*/

SecondMax {
  '' = Empty;
  e.seq = <Max <Del <Max e.seq> e.seq>>;
  e.1 = e.1 STOP;
}

/* 
Max вычисляет обычный максимум в списке чисел, т.е. находит число, 
которое >= всех остальных
*/

Max {
  '' = Empty;
  s.max = s.max; // max от одного элемента равен ему же
  s.max s.val e.seq, <Compare s.val s.max>: '+' = 
	  <Max s.val e.seq>; // рекурсивный вызов

/* 
Compare(сравнить) сравнивает два значения s.val и s.max,
если s.val > s.max выдаёт '+'
если s.val = s.max выдаёт '0'
если s.val < s.max выдаёт '-'

через запятую мы указываем условие: 
Compare s.val s.max>: '+' 
что тоже самое что и
s.val > s.max
двоеточие в данном случае значит равно(видимо равно уже занято, 
поэтому разработчики языка так выкрутились)
*/

  s.max s.val e.seq = 
	  <Max s.max e.seq>; // тут тоже вызываем рекурсивно функцию
// в s.max храним текущий максимум
// в e.seq остальные элементы, которые ещё предстоит проверить 
  e.1 = e.1 STOP; // выдаёт STOP если ни одна подстановка не удалась
}


// функция Del удаляет из списка все элементы равные s.value т.е. первому аргументу
Del {
  s.value e.1 s.value e.2 = <Del s.value e.1 e.2>;
  s.value e.1 = e.1;
  e.1 = e.1 Error;
}







2. Создать последовательность из‍ N‍ элементов последовательности Фибоначчи.

$ENTRY Go { 
= <Print <Fib 8>>;
}

Fib {
  0 e.seq = e.seq OK; // 0 элементов последовательности Фибоначчи обозначим OK
  s.count e.middle s.a s.b = 
	  <Fib <- s.count 1> e.middle s.a s.b <+ s.a s.b> >;
/*
s.count  - хранит кол-во элементов последовательности, которые нам осталось посчитать
e.middle - уже посчитанный кусок последовательности без двух последних элементов
s.a, s.b - собственно эти два последних элемента, которые нам нужно сложить
           чтобы достроить последовательность на один элемент вправо
!примечание: чтобы посчитать одну итерацию достаточно справа от равно стереть  <Fib ... > 
             и написать <- s.count 1> e.middle s.a s.b <+ s.a s.b>
*/
  s.count s.a = <Fib <- s.count 1> s.a 1>;
  s.count = <Fib <- s.count 1> 1>;
  e.1 = e.1 STOP;
}

3. Найти сумму элементов последовательности, имеющих чётную позицию.

$ENTRY Go { 
= <Print <DoEvenSum 1 2 3 4>>;
}

DoEvenSum {
  '' = Empty;
  e.1 = <Sum L 0 e.1>; // добавляем в начало метку L и число 0, в котором будем сохранять значение суммы
  e.1 = e.1 STOP;
}

Sum {
  L s.acc = s.acc; // s.acc от слова accumulator(накопитель) так назвал чтобы программа легче читалась
  R s.acc = s.acc; // в этих двух строках удаляем метку(L или R)
  L s.acc s.left e.right = <Sum R s.acc e.right>; 
  // если спереди метка L, то ничего не делаем
  R s.acc s.left e.right = <Sum L <+ s.acc s.left> e.right>;
  // если метка R, то складываем
  e.1 = e.1 STOP;
}

4. Переместить элементы последовательности по‍ кругу на‍ введённое пользователем число. 
Пример: для объектного выражения 1 2 3 4 5 и‍ числа‍ 1 ответом будет 5 1 2 3 4. Задачу решить без использования функции First.

// круг(окружность с точками(точки = элементы)) как бы разрезается в одном месте и превращается в список, который может "вращаться",
// вращается он так же как и соответствующие элементы круга, эту идею важно понимать :)
$ENTRY Go { 
= <Print <Rotate 3 1 2 3 4 5>>;
}
// функция Rotate осуществляет поворот на число, являющеся её первым аргументом
// т.е. список начинается со ВТОРОГО аргумента
Rotate {
  '' = Empty; // если "покрутить" пустой список он останется собой(перейдёт в себя)
  0 e.seq = e.seq; // если не надо крутить, то пусть будет всё как было
  s.count e.seq s.last = 
	  <Rotate <- s.count 1> s.last e.seq>;
	  /*
	  s.count  - кол-во поворотов, которое необходимо сделать дабы получить результат
	  e.seq s.last ->(переходит в) s.last e.seq
	  т.е. меняем местами часть списка e.seq и крайний правый элемент s.last
	  и затем вызывам этот метод рекурсивно
	  */
}

5. Переместить элементы последовательности по‍ кругу на‍ введённое пользователем число. 
Пример: для последовательности 1 2 3 4 5 и‍ числа 3 ответом будет 3 4 5 1 2. Задачу решить с‍ использованием функции First. При вводе числа, большего длины выражения, следует выводить сообщение об‍ ошибке.

$ENTRY Go { 
= <Print <Rotate 3 1 2 3 4 5>>;
}
// checkRotate проверяет введенное число больше ли оно длины всего списка
checkRotate {
  s.count e.seq, 
    <Compare s.count <Len e.seq>>: '+' = False;
	/*
	
	*/
  e.1 = True;
}
// функция Rotate осуществляет поворот на число, являющеся её первым аргументом
// т.е. список начинается со ВТОРОГО аргумента
Rotate {
  e.1, <checkRotate e.1>: False = Error;
  e.1 = <Swap <Last e.1>>;
  e.1 = e.1 STOP;
}
// функция Swap меняет местами две части списка, первая часть e.1 должна быть в скобках
// например <Swap (1 2) 5 6 7> => 5 6 7 1 2
Swap {
  (e.1) e.2 = e.2 e.1;
  e.1 = e.1 STOP;
}

// Len вычисляет длину списка, используя функцию Fst
Len {
  e.1 = <Fst <Lenw e.1>>;
}
// функция Fst возвращает первый слева элемент списка
Fst {
  s.1 e.1 = s.1;
  e.1 = e.1;
}